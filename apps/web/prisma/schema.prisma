generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// Auth (NextAuth.js)
// ============================================

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  stripeCustomerId String? @unique
  atsGenerationCount Int @default(0)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  accounts     Account[]
  sessions     Session[]
  profile      UserProfile?
  applications Application[]
  subscription Subscription?

  @@map("users")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

// ============================================
// User Profile
// ============================================

model UserProfile {
  id              String   @id @default(cuid())
  userId          String   @unique
  headline        String?
  targetRoles     String[] @default([])
  targetLocations String[] @default([])
  onboardingComplete Boolean @default(false)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  user        User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  baseResumes BaseResume[]

  @@map("user_profiles")
}

// ============================================
// Base Resumes (user's uploaded resume files)
// ============================================

model BaseResume {
  id          String   @id @default(cuid())
  profileId   String
  name        String   // User-friendly name, e.g., "Software Engineer Resume"
  fileName    String?  // Original filename, e.g., "John_Doe_Resume.pdf"
  fileType    String?  // MIME type, e.g., "application/pdf"
  fileSize    Int?     // Size in bytes
  filePath    String?  // Path to stored file (local or S3 key)
  content     Json?    // Optional: parsed resume data (ResumeData JSON)
  isDefault   Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  profile         UserProfile     @relation(fields: [profileId], references: [id], onDelete: Cascade)
  resumeVersions  ResumeVersion[]

  @@index([profileId])
  @@map("base_resumes")
}

// ============================================
// Applications
// ============================================

model Application {
  id                  String            @id @default(cuid())
  userId              String
  companyName         String
  title               String
  location            String?
  url                 String?
  description         String            @db.Text
  descriptionHash     String            // For detecting duplicate/changed JDs
  salary              String?
  source              String?           // linkedin, greenhouse, lever, etc.
  status              ApplicationStatus @default(SAVED)
  notes               String?           @db.Text
  appliedAt           DateTime?
  appliedWithResumeId String?           // Which base resume was used when applying
  finalResumeFileName String?           // The actual resume file used
  finalResumeFileType String?
  finalResumeFileSize Int?
  finalResumeFilePath String?
  finalResumeUploadedAt DateTime?
  createdAt           DateTime          @default(now())
  updatedAt           DateTime          @updatedAt

  user           User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  resumeVersions ResumeVersion[]
  contacts       Contact[]
  companyInfo    CompanyInfo?

  @@index([userId, status])
  @@index([userId, createdAt])
  @@map("applications")
}

enum ApplicationStatus {
  SAVED
  APPLIED
  PHONE_SCREEN
  INTERVIEW
  OFFER
  REJECTED
  WITHDRAWN
}

// ============================================
// Resume Versions
// ============================================

model ResumeVersion {
  id            String   @id @default(cuid())
  applicationId String
  baseResumeId  String?  // Which base resume this was generated from
  content       Json     // ResumeData JSON - the tailored resume content
  keywords      String[] @default([])
  pdfFileId     String?  // S3 key if we generate a PDF
  promptConfig  Json?    // What rules/prompts were used to generate this
  createdAt     DateTime @default(now())

  application Application @relation(fields: [applicationId], references: [id], onDelete: Cascade)
  baseResume  BaseResume? @relation(fields: [baseResumeId], references: [id], onDelete: SetNull)

  @@index([applicationId])
  @@index([baseResumeId])
  @@map("resume_versions")
}

// ============================================
// Billing
// ============================================

model Subscription {
  id                    String   @id @default(cuid())
  userId                String   @unique
  stripeCustomerId      String
  stripeSubscriptionId  String   @unique
  status                String
  currentPeriodEnd      DateTime?
  cancelAtPeriodEnd     Boolean  @default(false)
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("subscriptions")
}

// ============================================
// Contacts & Outreach
// ============================================

model Contact {
  id            String            @id @default(cuid())
  applicationId String
  name          String
  role          String?
  email         String?
  linkedinUrl   String?
  confidence    ContactConfidence @default(LOW)
  source        String?           // How we found them
  notes         String?
  createdAt     DateTime          @default(now())

  application      Application        @relation(fields: [applicationId], references: [id], onDelete: Cascade)
  outreachMessages OutreachMessage[]

  @@index([applicationId])
  @@map("contacts")
}

enum ContactConfidence {
  HIGH
  MEDIUM
  LOW
}

model OutreachMessage {
  id        String          @id @default(cuid())
  contactId String
  subject   String?
  body      String          @db.Text
  channel   OutreachChannel
  createdAt DateTime        @default(now())
  sentAt    DateTime?

  contact Contact @relation(fields: [contactId], references: [id], onDelete: Cascade)

  @@index([contactId])
  @@map("outreach_messages")
}

enum OutreachChannel {
  EMAIL
  LINKEDIN
}

// ============================================
// Company Research
// ============================================

model CompanyInfo {
  id            String   @id @default(cuid())
  applicationId String   @unique
  summary       String?  @db.Text
  product       String?
  industry      String?
  size          String?
  talkingPoints String[] @default([])
  interviewPrep String[] @default([])
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  application Application @relation(fields: [applicationId], references: [id], onDelete: Cascade)

  @@map("company_info")
}
